!function(){class t{highlighting=new Map;stats=new s;constructor(t,e=(()=>{})){this.array=t,this.onSnapshot=e}get length(){return this.array.length}get(t){return this.stats.reads++,this.array[t]}swap(t,e){this.stats.swaps++,this.mark(t,r.MOVE).mark(e,r.MOVE),[this.array[t],this.array[e]]=[this.get(e),this.get(t)]}move(t,e){this.stats.moves++,this.mark(e,r.MOVE);const s=this.get(t);this.array.splice(t,1),this.array.splice(e,0,s)}compareIndexes(t,e){return this.mark(t,r.COMPARISON).mark(e,r.COMPARISON),this.compareValues(this.get(t),this.get(e))}compareValues(t,e){return this.stats.comparisons++,new a(t-e)}mark(t,e,s=!1){return this.highlighting.get(t)?.isPermanent||this.highlighting.set(t,new n(e,s)),this}unmark(t){return this.highlighting.delete(t),this}takeSnapshot(){const t=this.getSnapshot();this.highlighting.forEach(((t,e)=>{t.isPermanent||this.highlighting.delete(e)})),this.onSnapshot(t,this)}getSnapshot(){return new e(this.array,this.highlighting)}}class e{constructor(t,e){this.array=t.slice(),this.highlighting=new Map(e)}}class s{reads=0;swaps=0;moves=0;comparisons=0}let r;var i;(i=r||(r={})).DEFAULT="black",i.INDEX="blue",i.COMPARISON="green",i.MOVE="red";class n{constructor(t,e=!0){this.type=t,this.isPermanent=e}}class a{constructor(t){this.result=t}get isGreater(){return this.result>0}get isGreaterOrEqual(){return this.result>=0}get isLess(){return this.result<0}get isLessOrEqual(){return this.result<=0}get isEqual(){return 0==this.result}}function o(t,e){return{description:t,sort:e}}function h(t){return t.replace(/\n/g,"")}const l=h('Bubble sort is a simple sorting algorithm that compares 2 adjacent values and swaps them if they\'re not in relative order.\n As a side effect of this, the largest values "bubble" to the top. \n The cost of using this algorithm scales exponentially with a time complexity of O(n^2).\n This algorithm splits the array into 2 sections: sorted and unsorted. \n The space complexity is O(1)'),c=t=>{for(let e=0;e<t.length-1;e++){const s=t.length-e-1;t.mark(s,r.INDEX,!0);let i=!1;for(let e=0;e<s;e++)t.compareIndexes(e,e+1).isGreater&&(t.swap(e,e+1),i=!0),t.takeSnapshot();if(t.unmark(s),!i)return t}return t},g=h("Selection sort sorts by finding the smallest value and bringing it to the beginning.\n Similar to bubble sorting, it splits the array into a sorted side and an unsorted side.\n It swaps less compared to bubble sorting, as it only swaps after searching the entire unsorted subarray.\n The time complexity is O(n^2) and the space complexity is O(1)."),u=t=>{for(let e=0;e<t.length-1;e++){let s=e;for(let i=e+1;i<t.length;i++)t.mark(e,r.INDEX),t.compareIndexes(i,s).isLess&&(s=i),t.takeSnapshot();t.swap(e,s),t.unmark(e)}return t},m=h("Insertion sort is a common algorithm used to sort cards in real life.\n The array is split into 2 sections, a (relatively) sorted and unsorted subarray.\n Elements are taken from the unsorted side and are inserted in the sorted side in order.\n Time complexity is O(n^2) and space complexity is O(1)"),p=t=>{for(let e=1;e<t.length;e++)for(let s=e-1;s>=0;s--){if(!t.compareIndexes(s,s+1).isGreater){t.takeSnapshot();break}t.swap(s,s+1),t.takeSnapshot()}return t},d=h("Quick sort is a commonly used algorithm with a worst case runtime complexity of n^2.\n Although on average, it has a time complexity of n log n.\n Like the name suggests, quick sort is pretty quick."),y=t=>(function e(s=0,r=t.length-1){if(t.compareValues(s,r).isGreaterOrEqual)return;const i=function(e,s){let r=e-1;for(let i=e;i<s;i++)t.takeSnapshot(),t.compareIndexes(i,s).isLessOrEqual&&(r++,t.swap(r,i));return r++,t.swap(r,s),r}(s,r);e(s,i-1),e(i+1,r)}(),t);const f=(new class{list={"Bubble Sort":o(l,c),"Selection Sort":o(g,u),"Insertion Sort":o(m,p),"Quick Sort":o(d,y)};get names(){return Object.keys(this.list)}get length(){return this.names.length}}).list;onmessage=e=>{const{name:s,array:r}=e.data;console.log(s);const i=new t(r,k);f[s].sort(i),i.takeSnapshot(),i.takeSnapshot(),self.close()};const k=t=>{self.postMessage(t)}}();
//# sourceMappingURL=worker.47eebc7d.js.map
